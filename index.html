<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Unlucky Commuter</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;800&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Montserrat', sans-serif;
            touch-action: none; /* Prevent scrolling on mobile */
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        /* UI Overlay for non-canvas elements if needed, mostly doing canvas UI */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
</div>

<script>
/**
 * THE UNLUCKY COMMUTER: IMMERSIVE EDITION
 * Designed by Zain Ul Abideen
 * AI Integration by Gemini
 */

const apiKey = ""; // System provides this key at runtime

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // Optimize

// --- CONFIGURATION & STATE ---
let GAME = {
    width: 0,
    height: 0,
    state: 'MENU', // MENU, LEVEL_SELECT, DIFF_SELECT, PLAYING, GAMEOVER, WIN
    frame: 0,
    speed: 0,
    baseSpeed: 6,
    distance: 0,
    goalDistance: 5000,
    theme: 'METRO',
    difficulty: 'NORMAL',
    highQuality: true,
    horoscope: "", // Store AI horoscope
    aftermath: "", // Store AI game over text
    isAiLoading: false
};

const THEMES = {
    METRO: {
        name: "Metro City",
        skyTop: '#1a2a6c',
        skyBottom: '#b21f1f',
        ground: '#2C3E50',
        road: '#34495E',
        roadLine: '#F1C40F',
        decor: 'BUILDING',
        destinationName: 'Central Station'
    },
    AIRPORT: {
        name: "Sky Harbor",
        skyTop: '#2980b9',
        skyBottom: '#6dd5fa',
        ground: '#7f8c8d',
        road: '#95a5a6',
        roadLine: '#ecf0f1',
        decor: 'CLOUD_TOWER',
        destinationName: 'Terminal 1'
    },
    TRAIN: {
        name: "Countryside Rails",
        skyTop: '#56ab2f',
        skyBottom: '#a8e063',
        ground: '#5D4037',
        road: '#795548',
        roadLine: '#8D6E63', // Wood ties
        decor: 'TREE',
        destinationName: 'Steam Engine'
    }
};

const DIFFICULTY = {
    EASY: { speed: 5, luckDrain: 0.5, obsFreq: 180 },
    MEDIUM: { speed: 8, luckDrain: 0.8, obsFreq: 120 },
    HARD: { speed: 12, luckDrain: 1.2, obsFreq: 70 }
};

// --- GEMINI API INTEGRATION ---

async function getHoroscope() {
    if (GAME.isAiLoading) return;
    GAME.isAiLoading = true;
    GAME.horoscope = "Reading the stars...";

    try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{ parts: [{ text: "Write a short, one-sentence, funny, and slightly ominous horoscope for a commuter about to walk to work. Mention specific absurd dangers like rogue bananas or open portals." }] }]
            })
        });
        const data = await response.json();
        GAME.horoscope = data.candidates[0].content.parts[0].text;
    } catch (e) {
        GAME.horoscope = "The stars are silent (Network Error).";
    }
    GAME.isAiLoading = false;
}

async function getAftermathReport(cause) {
    if (GAME.isAiLoading) return;
    GAME.isAiLoading = true;
    GAME.aftermath = "Consulting the Cosmic Oracle...";

    const dest = THEMES[GAME.theme].destinationName;
    const dist = Math.floor(GAME.distance / 10);
    const prompt = `You are a sarcastic narrator for a game called 'The Unlucky Commuter'. 
    The player was trying to reach ${dest} but failed by ${cause} after walking ${dist} meters. 
    Write a short (max 2 sentences), funny, cosmic reason why the universe conspired against them. Be snarky.`;

    try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{ parts: [{ text: prompt }] }]
            })
        });
        const data = await response.json();
        GAME.aftermath = data.candidates[0].content.parts[0].text;
    } catch (e) {
        GAME.aftermath = "The Oracle is on a coffee break.";
    }
    GAME.isAiLoading = false;
}


// --- INPUT HANDLING ---
const INPUT = {
    active: false,
    tap: false,
    x: 0,
    y: 0
};

function handleStart(e) {
    e.preventDefault(); 
    INPUT.active = true; 
    INPUT.tap = true;
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    INPUT.x = clientX - rect.left;
    INPUT.y = clientY - rect.top;
}

function handleEnd(e) {
    e.preventDefault(); 
    INPUT.active = false; 
}

window.addEventListener('mousedown', handleStart);
window.addEventListener('touchstart', handleStart, {passive: false});
window.addEventListener('mouseup', handleEnd);
window.addEventListener('touchend', handleEnd);
window.addEventListener('keydown', (e) => { if(e.code === 'Space') INPUT.active = true; });
window.addEventListener('keyup', (e) => { if(e.code === 'Space') INPUT.active = false; });


// --- CLASSES ---

class Player {
    constructor() {
        this.width = 40;
        this.height = 70; // "Small looking" 4ft relative height
        this.x = 150;
        this.y = 0;
        this.vy = 0;
        this.groundY = 0;
        this.state = 'RUNNING'; // RUNNING, JUMPING, FLOATING, SLIPPING, FALLING
        this.luck = 100;
        this.rotation = 0;
        this.scale = 1;
        this.animTimer = 0;
    }

    update() {
        this.groundY = GAME.height * 0.75;

        // Power / Jump Logic
        if (GAME.state === 'PLAYING') {
            if (INPUT.active && this.luck > 0) {
                // Divine Luck (Float)
                this.state = 'FLOATING';
                this.vy -= 0.8; // Lift
                this.luck -= DIFFICULTY[GAME.difficulty].luckDrain;
                if (this.y < this.groundY - 150) this.vy = 0.5; // Ceiling
            } else {
                // Gravity
                this.vy += 0.6;
                if (this.y < this.groundY) {
                    this.state = 'JUMPING';
                }
            }

            // Physics application
            this.y += this.vy;

            // Floor collision
            if (this.y >= this.groundY) {
                this.y = this.groundY;
                this.vy = 0;
                if (this.state !== 'SLIPPING') this.state = 'RUNNING';
            }

            // Luck regen
            if (!INPUT.active && this.luck < 100 && this.state === 'RUNNING') {
                this.luck += 0.2;
            }
        } 
        else if (GAME.state === 'GAMEOVER') {
            if (this.state === 'SLIPPING') {
                // Slip physics: slide forward and rotate
                this.x += 4;
                this.y += this.vy;
                this.vy += 0.5;
                if(this.y >= this.groundY) {
                    this.y = this.groundY;
                    this.vy = -2; // Bounce slightly
                }
                this.rotation += 0.1;
            }
            else if (this.state === 'FALLING') {
                // Fall into hole: Scale down and drop
                this.scale -= 0.05;
                this.y += 5;
                this.rotation += 0.05;
                if(this.scale < 0) this.scale = 0;
            }
        }

        this.animTimer += 0.15;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.scale(this.scale, this.scale);

        // Shadow (Dynamic)
        if (this.state !== 'FALLING') {
            ctx.save();
            ctx.translate(0, -this.y + this.groundY); // Project to ground
            ctx.scale(1 - (this.groundY - this.y)/300, 1); // Shrink shadow as we go up
            ctx.beginPath();
            ctx.ellipse(0, 10, 20, 5, 0, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.fill();
            ctx.restore();
        }

        // Divine Glow
        if (this.state === 'FLOATING') {
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 30;
        } else {
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetY = 5;
        }

        // Character Rendering (Procedural 3D-ish look)
        // Legs
        let legOffset = Math.sin(this.animTimer) * 10;
        if (this.state !== 'RUNNING') legOffset = 0;

        ctx.fillStyle = '#333'; // Pants
        // Back Leg
        ctx.beginPath();
        ctx.roundRect(-10 + legOffset, -30, 8, 30, 4);
        ctx.fill();
        // Front Leg
        ctx.beginPath();
        ctx.roundRect(2 - legOffset, -30, 8, 30, 4);
        ctx.fill();

        // Body (Shirt)
        const shirtColor = GAME.theme === 'METRO' ? '#E74C3C' : (GAME.theme === 'AIRPORT' ? '#3498DB' : '#E67E22');
        ctx.fillStyle = shirtColor;
        ctx.beginPath();
        ctx.roundRect(-12, -55, 24, 30, 5);
        ctx.fill();

        // Head
        ctx.fillStyle = '#F1C40F'; // Skin tone
        ctx.beginPath();
        ctx.arc(0, -65, 12, 0, Math.PI*2);
        ctx.fill();

        // Arms
        ctx.fillStyle = shirtColor;
        ctx.beginPath();
        ctx.roundRect(-14 - legOffset, -50, 6, 20, 3); // Arm swings opposite to legs
        ctx.fill();

        // Accessories (Backpack)
        ctx.fillStyle = '#555';
        ctx.beginPath();
        ctx.roundRect(-18, -53, 6, 20, 2);
        ctx.fill();

        ctx.restore();
    }
}

class Obstacle {
    constructor(type, x) {
        this.type = type; // 'HOLE' or 'BANANA'
        this.x = x;
        this.width = 40;
        this.height = 20;
        this.passed = false;
    }

    update() {
        this.x -= GAME.speed;
    }

    draw(ctx, groundY) {
        // Simulate perspective by scaling based on Y (though strictly 2D gameplay)
        // Draw relative to ground
        
        if (this.type === 'HOLE') {
            ctx.save();
            ctx.translate(this.x, groundY + 5);
            ctx.scale(1, 0.3); // Flatten circle to look like 3D hole on ground
            
            // Hole Gradient (Depth)
            let grad = ctx.createRadialGradient(0,0, 5, 0,0, 25);
            grad.addColorStop(0, '#000');
            grad.addColorStop(1, '#333');
            
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI*2);
            ctx.fill();
            
            // Inner rim
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        } 
        else if (this.type === 'BANANA') {
            ctx.save();
            ctx.translate(this.x, groundY);
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 2, 15, 3, 0, 0, Math.PI*2);
            ctx.fill();

            // Banana Shape
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-10, -5);
            ctx.quadraticCurveTo(0, 5, 10, -5);
            ctx.stroke();
            
            // Stem
            ctx.strokeStyle = '#3E2723';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(10, -5);
            ctx.lineTo(13, -8);
            ctx.stroke();
            
            ctx.restore();
        }
    }
}

class Scenery {
    constructor(type, x) {
        this.type = type;
        this.x = x;
        this.depth = Math.random() * 0.5 + 0.5; // Parallax factor
    }

    update() {
        this.x -= GAME.speed * 0.5; // Background moves slower
    }

    draw(ctx, theme, groundY) {
        ctx.save();
        ctx.translate(this.x, groundY);
        
        // Simulate distance fog
        // ctx.globalAlpha = this.depth; 

        if (theme.decor === 'BUILDING') {
            // 3D Isometric-ish Building
            let h = 100 + Math.random() * 100;
            let w = 40 + Math.random() * 30;
            
            // Front face
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, -h, w, h);
            
            // Side face (3D effect)
            ctx.fillStyle = '#1a252f';
            ctx.beginPath();
            ctx.moveTo(w, -h);
            ctx.lineTo(w+15, -h-10);
            ctx.lineTo(w+15, -10);
            ctx.lineTo(w, 0);
            ctx.fill();
            
            // Windows
            ctx.fillStyle = '#f1c40f';
            for(let i=10; i<h-10; i+=20) {
                if(Math.random()>0.3) ctx.fillRect(5, -i, 10, 10);
                if(Math.random()>0.3) ctx.fillRect(20, -i, 10, 10);
            }
        } 
        else if (theme.decor === 'TREE') {
            // Fractal-like Tree
            ctx.fillStyle = '#5D4037';
            ctx.fillRect(0, -60, 10, 60); // Trunk
            
            ctx.fillStyle = '#2E7D32';
            // Leaves clumps
            ctx.beginPath(); ctx.arc(5, -70, 25, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(-10, -60, 20, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(20, -60, 20, 0, Math.PI*2); ctx.fill();
        }
        else if (theme.decor === 'CLOUD_TOWER') {
             // Control Tower or Clouds
             if (Math.random() > 0.5) {
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.beginPath();
                ctx.arc(0, -150, 30, 0, Math.PI*2);
                ctx.arc(20, -160, 40, 0, Math.PI*2);
                ctx.arc(40, -150, 30, 0, Math.PI*2);
                ctx.fill();
             } else {
                 // Simple Tower
                 ctx.fillStyle = '#95a5a6';
                 ctx.fillRect(0, -100, 20, 100);
                 ctx.fillStyle = '#bdc3c7';
                 ctx.beginPath();
                 ctx.moveTo(-10, -100);
                 ctx.lineTo(30, -100);
                 ctx.lineTo(10, -130);
                 ctx.fill();
             }
        }

        ctx.restore();
    }
}

// --- GAME ENGINE ---

let player = new Player();
let obstacles = [];
let scenery = [];
let particles = [];

function initGame() {
    player = new Player();
    obstacles = [];
    scenery = [];
    GAME.distance = 0;
    GAME.speed = DIFFICULTY[GAME.difficulty].speed;
    GAME.state = 'PLAYING';
    GAME.aftermath = ""; // Reset AI text
    
    // Pre-populate scenery
    for(let i=0; i<10; i++) {
        scenery.push(new Scenery(null, i * 200));
    }
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    GAME.width = canvas.width;
    GAME.height = canvas.height;
}
window.addEventListener('resize', resize);
resize();

function update() {
    GAME.frame++;

    if (GAME.state === 'PLAYING') {
        GAME.distance += GAME.speed;
        
        // Spawn Obstacles
        if (GAME.distance < GAME.goalDistance - 1000) { // Don't spawn near goal
            if (GAME.frame % DIFFICULTY[GAME.difficulty].obsFreq === 0) {
                if (Math.random() > 0.3) {
                    let type = Math.random() > 0.5 ? 'HOLE' : 'BANANA';
                    obstacles.push(new Obstacle(type, GAME.width + 100));
                }
            }
        }

        // Spawn Scenery
        if (GAME.frame % 60 === 0) {
            scenery.push(new Scenery(null, GAME.width + 100));
        }

        // Collision Logic
        obstacles.forEach(obs => {
            // Hitbox logic (AABB)
            let pLeft = player.x - 10;
            let pRight = player.x + 10;
            let pBottom = player.y;
            let obsLeft = obs.x - 15;
            let obsRight = obs.x + 15;

            // Collision check
            if (pRight > obsLeft && pLeft < obsRight) {
                // Only collide if close to ground
                if (pBottom > player.groundY - 10) {
                    if (obs.type === 'BANANA') {
                        player.state = 'SLIPPING';
                        player.vy = -5; // Pop up slightly
                        GAME.state = 'GAMEOVER';
                    } else if (obs.type === 'HOLE') {
                        player.state = 'FALLING';
                        player.y = player.groundY + 10; // Center in hole
                        GAME.state = 'GAMEOVER';
                    }
                }
            }
        });

        if (GAME.distance >= GAME.goalDistance) {
            GAME.state = 'WIN';
        }
    }

    player.update();
    obstacles.forEach(o => o.update());
    scenery.forEach(s => s.update());
    
    // Cleanup
    obstacles = obstacles.filter(o => o.x > -200);
    scenery = scenery.filter(s => s.x > -200);

    // Interaction Reset removed from here to allow drawGame to see taps
}

// Helper to wrap text for canvas
function wrapText(context, text, x, y, maxWidth, lineHeight) {
    let words = text.split(' ');
    let line = '';

    for(let n = 0; n < words.length; n++) {
      let testLine = line + words[n] + ' ';
      let metrics = context.measureText(testLine);
      let testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        context.fillText(line, x, y);
        line = words[n] + ' ';
        y += lineHeight;
      }
      else {
        line = testLine;
      }
    }
    context.fillText(line, x, y);
}

function drawMenu() {
    const theme = THEMES[GAME.theme];
    // Background
    let grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grad.addColorStop(0, '#1a2a6c');
    grad.addColorStop(1, '#b21f1f');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, GAME.width, GAME.height);

    // Animated Pattern
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 2;
    for(let i=0; i<GAME.width; i+=50) {
        ctx.beginPath();
        ctx.moveTo(i + (Math.sin(GAME.frame * 0.01 + i)*50), 0);
        ctx.lineTo(i + (Math.cos(GAME.frame * 0.01 + i)*50), GAME.height);
        ctx.stroke();
    }

    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowBlur = 20;

    // --- UPDATED MENU LOGIC WITH DYNAMIC POSITIONING ---
    if (GAME.state === 'MENU') {
        ctx.fillStyle = '#FFF';
        // Title area roughly top 25%
        ctx.font = '900 60px Montserrat';
        ctx.fillText("UNLUCKY COMMUTER", GAME.width/2, GAME.height * 0.25);
        
        ctx.font = '400 20px Montserrat';
        ctx.fillText("The journey of a thousand slips...", GAME.width/2, GAME.height * 0.25 + 40);

        // Start button at 50% height
        drawButton(GAME.width/2, GAME.height * 0.5, "START GAME", () => GAME.state = 'LEVEL_SELECT');

        // Horoscope button below start
        drawButton(GAME.width/2, GAME.height * 0.5 + 70, "✨ GET HOROSCOPE", () => getHoroscope(), '#9b59b6');
        
        // Text area below buttons with padding
        if (GAME.horoscope) {
            ctx.font = 'italic 16px Montserrat';
            ctx.fillStyle = '#FFF';
            // Dynamic width wrapper
            let maxW = Math.min(600, GAME.width * 0.8);
            wrapText(ctx, GAME.horoscope, GAME.width/2, GAME.height * 0.5 + 130, maxW, 20);
        }

    } else if (GAME.state === 'LEVEL_SELECT') {
        ctx.fillStyle = '#FFF';
        ctx.font = '800 40px Montserrat';
        ctx.fillText("SELECT YOUR ROUTE", GAME.width/2, GAME.height * 0.2);

        // Start buttons at 40% height, spacing based on height
        let startY = GAME.height * 0.4;
        let gap = Math.min(80, GAME.height * 0.15); // Max 80px gap, or 15% height

        drawButton(GAME.width/2, startY, "METRO CITY", () => { GAME.theme = 'METRO'; GAME.state = 'DIFF_SELECT'; }, THEMES.METRO.skyTop);
        drawButton(GAME.width/2, startY + gap, "AIRPORT", () => { GAME.theme = 'AIRPORT'; GAME.state = 'DIFF_SELECT'; }, THEMES.AIRPORT.skyTop);
        drawButton(GAME.width/2, startY + gap * 2, "TRAIN STATION", () => { GAME.theme = 'TRAIN'; GAME.state = 'DIFF_SELECT'; }, THEMES.TRAIN.skyBottom);

    } else if (GAME.state === 'DIFF_SELECT') {
        ctx.fillStyle = '#FFF';
        ctx.font = '800 40px Montserrat';
        ctx.fillText("SELECT DIFFICULTY", GAME.width/2, GAME.height * 0.2);

        let startY = GAME.height * 0.4;
        let gap = Math.min(80, GAME.height * 0.15);

        drawButton(GAME.width/2, startY, "EASY", () => { GAME.difficulty = 'EASY'; initGame(); }, '#2ecc71');
        drawButton(GAME.width/2, startY + gap, "MEDIUM", () => { GAME.difficulty = 'MEDIUM'; initGame(); }, '#f1c40f');
        drawButton(GAME.width/2, startY + gap * 2, "DIFFICULT", () => { GAME.difficulty = 'HARD'; initGame(); }, '#c0392b');
    }

    // Copyright (Bottom Left)
    ctx.textAlign = 'left';
    ctx.font = '400 14px Montserrat';
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.fillText("Designed By Zain Ul Abideen", 20, GAME.height - 20);
}

function drawButton(x, y, text, action, colorOverride) {
    let w = 250, h = 60;
    let hover = (INPUT.x > x - w/2 && INPUT.x < x + w/2 && INPUT.y > y - h/2 && INPUT.y < y + h/2);
    
    ctx.fillStyle = colorOverride || (hover ? '#FFF' : 'rgba(255,255,255,0.2)');
    if (hover && !colorOverride) ctx.fillStyle = '#FFF';
    
    // Button Shadow
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowBlur = 10;
    
    ctx.beginPath();
    ctx.roundRect(x - w/2, y - h/2, w, h, 10);
    ctx.fill();
    
    ctx.shadowBlur = 0;
    ctx.fillStyle = (hover && !colorOverride) ? '#000' : '#FFF';
    if (colorOverride) ctx.fillStyle = '#FFF';
    
    ctx.font = '700 18px Montserrat';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x, y);

    if (hover && INPUT.tap) {
        action();
        INPUT.tap = false; // Consume tap
    }
}

function drawGame() {
    const theme = THEMES[GAME.theme];
    
    // 1. Sky (Gradient)
    let grad = ctx.createLinearGradient(0, 0, 0, GAME.height);
    grad.addColorStop(0, theme.skyTop);
    grad.addColorStop(1, theme.skyBottom);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, GAME.width, GAME.height);

    // 2. Scenery (Parallax Layer)
    scenery.forEach(s => s.draw(ctx, theme, GAME.height * 0.75));

    // 3. Road (Perspective)
    const horizonY = GAME.height * 0.75;
    const bottomY = GAME.height;
    
    // Ground fill
    ctx.fillStyle = theme.ground;
    ctx.fillRect(0, horizonY, GAME.width, GAME.height - horizonY);

    // Road Trapezoid
    ctx.fillStyle = theme.road;
    ctx.beginPath();
    ctx.moveTo(0, bottomY);
    ctx.lineTo(GAME.width, bottomY);
    ctx.lineTo(GAME.width, horizonY); // Flat horizon for side scroller
    ctx.lineTo(0, horizonY);
    ctx.fill();

    // Road Lines (Moving)
    ctx.strokeStyle = theme.roadLine;
    ctx.lineWidth = 4;
    ctx.setLineDash([40, 40]);
    ctx.lineDashOffset = -GAME.distance; // Animation
    ctx.beginPath();
    ctx.moveTo(0, horizonY + 10);
    ctx.lineTo(GAME.width, horizonY + 10);
    ctx.stroke();
    ctx.setLineDash([]);

    // 4. Shadows & Objects
    obstacles.forEach(o => o.draw(ctx, horizonY));

    // 5. Player
    player.draw(ctx);

    // 6. HUD
    drawHUD();

    // 7. Overlays (Game Over / Win)
    if (GAME.state === 'GAMEOVER' || GAME.state === 'WIN') {
        ctx.fillStyle = 'rgba(0,0,0,0.85)';
        ctx.fillRect(0, 0, GAME.width, GAME.height);
        
        ctx.textAlign = 'center';
        ctx.fillStyle = '#FFF';
        ctx.font = '800 50px Montserrat';
        
        let msg = GAME.state === 'WIN' ? "SAFE ARRIVAL!" : "OUCH!";
        let sub = GAME.state === 'WIN' ? `Welcome to ${theme.destinationName}` : "Try using your Powers!";
        
        ctx.fillText(msg, GAME.width/2, GAME.height/2 - 60);
        ctx.font = '400 20px Montserrat';
        ctx.fillText(sub, GAME.width/2, GAME.height/2 - 20);

        // AI AFTERMATH FEATURE
        let whyMeText = GAME.state === 'WIN' ? "✨ ASK: HOW DID I SURVIVE?" : "✨ ASK: WHY DID I FALL?";
        let cause = player.state === 'SLIPPING' ? 'slipping on a banana' : 'falling into a hole';
        
        drawButton(GAME.width/2, GAME.height/2 + 40, whyMeText, () => getAftermathReport(cause), '#9b59b6');
        
        if (GAME.aftermath) {
             ctx.font = 'italic 18px Montserrat';
             ctx.fillStyle = '#f1c40f';
             // Dynamic width for Game Over text too
             let maxW = Math.min(700, GAME.width * 0.85);
             wrapText(ctx, `"${GAME.aftermath}"`, GAME.width/2, GAME.height/2 + 110, maxW, 25);
        }

        drawButton(GAME.width/2, GAME.height/2 + 180, "MAIN MENU", () => GAME.state = 'MENU');
    }
}

function drawHUD() {
    // Luck Bar
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(20, 20, 200, 20);
    
    // Fill
    let luckPct = player.luck / 100;
    let barColor = luckPct > 0.5 ? '#f1c40f' : '#e74c3c';
    ctx.fillStyle = barColor;
    ctx.fillRect(22, 22, 196 * luckPct, 16);
    
    ctx.fillStyle = '#FFF';
    ctx.font = '700 12px Montserrat';
    ctx.textAlign = 'left';
    ctx.fillText("DIVINE POWER", 20, 15);

    // Distance
    ctx.textAlign = 'right';
    ctx.font = '700 20px Montserrat';
    let distLeft = Math.max(0, Math.floor((GAME.goalDistance - GAME.distance)/10)) + "m";
    ctx.fillText(distLeft, GAME.width - 20, 40);
    ctx.font = '400 12px Montserrat';
    ctx.fillText("TO " + THEMES[GAME.theme].destinationName.toUpperCase(), GAME.width - 20, 20);
}

function loop() {
    ctx.clearRect(0, 0, GAME.width, GAME.height);

    if (['MENU', 'LEVEL_SELECT', 'DIFF_SELECT'].includes(GAME.state)) {
        drawMenu();
    } else {
        update();
        drawGame();
    }

    // Reset tap at the very end of the frame
    // This ensures buttons in both drawMenu AND drawGame have a chance to react
    if (INPUT.tap) INPUT.tap = false;

    requestAnimationFrame(loop);
}

// Start
loop();

</script>
</body>
</html>

